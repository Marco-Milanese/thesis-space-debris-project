import torch
import torch.nn as nn
from math import floor

class YoloLoss(nn.Module):

    def __init__(self, S=16):
        super(YoloLoss, self).__init__()
        self.mse = nn.MSELoss(reduction="sum")
        self.S = S

        # lambdas from Yolo paper
        self.lambda_noobj = 0.5
        self.lambda_coord = 5


    def forward(self, predictions, target):

        # predictions are the bboxes generated by the model. Shaped 16x16x5 (WxHxC)
        # target is the ground truth bboxes in the [c, x, y, w, h, n] format relative to the cell size, c is the confidence, n the number of the cell

        # each channel of the prediction is a parameter of the bbox
        # the first 5 channels are the first bbox

        #predictions[C][W][H]

        #n = floor(x/cellSize) + (floor(y/cellSize)) * S
        # target is a tuple containing all the bounding boxes

        objLoss = 0
        noObjLoss = 0
        for i in range(len(target)):
            nTargets = []
            for j in range(len(target[i])):
                nTarget = int(target[i][j][5])
                nTargets.append(nTarget)
                cellRow = floor(nTarget/self.S)
                cellCol = nTarget % self.S
                
                objLoss += (
                    self.mse(target[i][j][1], predictions[i][1][cellRow][cellCol]) +
                    self.mse(target[i][j][2], predictions[i][2][cellRow][cellCol]) +
                    self.mse(torch.sqrt(torch.clamp(target[i][j][3], min = 1e-6)), torch.sqrt(torch.clamp(predictions[i][3][cellRow][cellCol], min = 1e-6))) +
                    self.mse(torch.sqrt(torch.clamp(target[i][j][4], min = 1e-6)), torch.sqrt(torch.clamp(predictions[i][4][cellRow][cellCol], min = 1e-6))) +
                    self.mse(target[i][j][0], predictions[i][0][cellRow][cellCol])
                )
            
            
            for j in range(self.S):
                for k in range(self.S):
                    if (j * self.S) + k not in nTargets:
                        noObjLoss += self.mse(torch.zeros_like(predictions[i][0][j][k]), predictions[i][0][j][k])



        totalLoss = self.lambda_coord * objLoss + self.lambda_noobj * noObjLoss

        return totalLoss